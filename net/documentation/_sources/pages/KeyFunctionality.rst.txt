Key Functionality
#################

Establishing Communication
==========================

Connecting to the Unit
----------------------
It is first necessary to create a :class:`~VNSDK::Sensor` object, which we will use to send commands to the VectorNav unit.

.. tab:: C#
   
      .. literalinclude:: ../../../cs/examples/GettingStarted/GettingStarted.cs
         :language: c#
         :start-at: Sensor();
         :end-at: Sensor();
         :dedent: 12

.. tab:: MATLAB

      .. literalinclude:: ../../../matlab/examples/GettingStarted/GettingStarted.m
         :language: matlab
         :start-at: Sensor();
         :end-at: ();
         :dedent: 4

We can then connect to the VectorNav unit using the :func:`~VNSDK::Sensor::AutoConnect` method.

.. tab:: C#

   .. literalinclude:: ../../../cs/examples/GettingStarted/GettingStarted.cs
      :language: c#
      :start-at: try
      :end-before: sensor.ConnectedBaudRate()
      :dedent: 12

.. tab:: MATLAB

   .. literalinclude:: ../../../matlab/examples/GettingStarted/GettingStarted.m
      :language: matlab
      :start-at: try
      :end-before: sensor.ConnectedBaudRate()
      :dedent: 0

.. tip::
   If the baud rate is known, the :func:`~VNSDK::Sensor::Connect` method can be used, which accepts an extra parameter of the expected baud rate. This is a quicker call, as it does not require scanning all the baud rates.
   However, this method does not perform any verification of connectivity, so it is necessary to call :func:`~VNSDK::Sensor::VerifySensorConnectivity` to ensure communication.

   .. tab:: C#

      .. code-block:: C#

         Sensor sensor = new Sensor();
         try
         {
            sensor.Connect("COM8", Sensor.BaudRate.Baud115200);
         }
         catch (Exception e)
         {
            Console.WriteLine($"Error: Failed to connect to sensor. Reason: {e.Message}");
            return;
         }
         if (!sensor.VerifySensorConnectivity())
         {
               Console.WriteLine("Error: Failed to connect to unit.");
               return 1;
         }

   .. tab:: MATLAB

      .. code-block:: matlab
         
         sensor = Sensor();
         try
            sensor.Connect('COM8', Sensor.BaudRate.(BaudRate+BaudRates).Baud115200);
         catch e
            error('Error: Failed to connect to unit. Reason: %s\n', e.message);
         end
         if ~sensor.VerifySensorConnectivity()
            error('Error: Failed to connect to unit.');
         end

   If :func:`~VNSDK::Sensor::AutoConnect` is used, no :func:`~VNSDK::Sensor::VerifySensorConnectivity` call is necessary, as it verifies connectivity through the auto connection process at each baud rate. It is therefore the slower of the two methods, by default requiring a maximum of 4.5 seconds.

   To maintain robustness while maintaining the speed of the :func:`~VNSDK::Sensor::Connect` method, the :func:`~VNSDK::Sensor::AutoConnect` can be used as a fallback when :func:`~VNSDK::Sensor::VerifySensorConnectivity` fails.

.. Both :func:`~VNSDK::Sensor::Connect` and :func:`~VNSDK::Sensor::AutoConnect` will additionally begin a new *listening thread* (This does not occur if threading is disabled. For more information see :ref:`pages/Single-Threaded Operation`). 

Changing Baud Rate
------------------

Once communication has been established, the baud rate can be reconfigured at any point using the :func:`~VNSDK::Sensor::ChangeBaudRate` method.

.. tab:: C#

   .. code-block:: C#

      // Change baud rate on the active serial port
      sensor.ChangeBaudRate(921600);
      // Change baud rate on a specific serial port
      sensor.ChangeBaudRate(921600, 1);

.. tab:: MATLAB

   .. code-block:: matlab

      % Change baud rate on the active serial port
      sensor.ChangeBaudRate(921600);
      % Change baud rate on a specific serial port
      sensor.ChangeBaudRate(921600, 1);

.. note::
   The :func:`~VNSDK::Sensor::ChangeBaudRate` method will send a command to the unit to reconfigure its baud rate on the specified serial port. If the targeted port is the currently active one, it will update the host's baud rate to match.

.. tip::
   To ensure the baud rate change persists over a unit power cycle, a :func:`~VNSDK::Sensor::WriteSettings` command should be sent.

   .. tab:: C#

      .. code-block:: C#

         sensor.WriteSettings();

   .. tab:: MATLAB

      .. code-block:: matlab

         sensor.WriteSettings();


Disconnecting From the Unit
---------------------------

To disconnect from the unit, the :func:`~VNSDK::Sensor::Disconnect` method can be called, which also closes the *listening thread*.

.. tab:: C#

   .. literalinclude:: ../../../cs/examples/GettingStarted/GettingStarted.cs
      :language: c#
      :start-at: sensor.Disconnect();
      :end-at: sensor.Disconnect();
      :dedent: 12

.. tab:: MATLAB

   .. literalinclude:: ../../../matlab/examples/GettingStarted/GettingStarted.m
      :language: matlab
      :start-after: %% 7
      :end-at: sensor.Disconnect();
      
Accessing Registers
===================
All configuration settings and many measurements are stored in one of 256 registers, which are accessible via synchronous polling and synchronous writing

.. The SDK contains the complete register definitions in :ref:`file_include_Interface_Registers.hpp`, each defined as a class with each register field a public class member.
.. All of the register classes exist in the :ref:`namespace_VN__Registers` and a namespace for the register group. Alternatively, each register is aliased under the :ref:`namespace_VN__Registers__ById` by their register ID. For example, the ``Synchronization Control`` class can either be accessed as :class:`VNSDK::Registers::System::SyncControl` or :type:`VNSDK::Registers::ById::reg32`.

Both measurement registers and configuration registers can be read, whereas only configuration registers can be written. This is accomplished best using the :func:`~VNSDK::Sensor::ReadRegister` and :func:`~VNSDK::Sensor::WriteRegister` methods, which are discussed in the following sections. 

.. The :func:`~VNSDK::Sensor::ReadRegister` and :func:`~VNSDK::Sensor::WriteRegister` methods are calls which block upon reception of the unit's response, with a timeout length of :member:`VNSDK::Config::Sensor::commandSendTimeoutLength` (set in :ref:`file_include_Config.hpp`). If no response is received in time and retry is enabled, they will retry the number of :member:`VNSDK::Config::Sensor::commandSendRetriesAllowed` (set in :ref:`file_include_Config.hpp`). If all retries fail to receive a response, they will return ``Error::ResponseTimeout``. If the unit responds with a valid, non-VnError response within the timeout length, the fields of the passed ``Register`` object will be populated with the unit's response.

The fields in each :class:`~VNSDK::Registers::MeasRegister` and :class:`~VNSDK::Registers::ConfigRegister` object will match the fields listed in the VectorNav unit's latest ICD, which can be downloaded directly from VectorNav's website.

.. .. note::
   .. The :func:`~VNSDK::Sensor::ReadRegister` and :func:`~VNSDK::Sensor::WriteRegister` methods are blocking calls. There is currently no mechanism for non-blocking calls.

Reading Registers
-----------------

As discussed in :ref:`pages/KeyFunctionality:Accessing Registers`, the :func:`~VNSDK::Sensor::ReadRegister` method is the preferred method to read registers. To do so, you must 

   #. Create a :class:`~VNSDK::Registers::MeasRegister` or :class:`~VNSDK::Registers::ConfigRegister` object to be populated by the received response
   #. Call the :func:`~VNSDK::Sensor::ReadRegister` method
   #. Access the received values in the original :class:`~VNSDK::Registers::MeasRegister` or :class:`~VNSDK::Registers::ConfigRegister` object

.. tab:: C#

   .. literalinclude:: ../../../cs/examples/GettingStarted/GettingStarted.cs
      :language: c#
      :start-at: VNSDK.Registers.Attitude.YawPitchRoll 
      :end-at: $"Roll: {yprRegister.roll}");
      :dedent: 12

.. tab:: MATLAB

   .. literalinclude:: ../../../matlab/examples/GettingStarted/GettingStarted.m
      :language: matlab
      :start-at: yprRegister = Registers.Attitude.YawPitchRoll();
      :end-at: yprRegister.roll


Writing Registers
-----------------

As discussed in :ref:`pages/KeyFunctionality:Accessing Registers`, the :func:`~VNSDK::Sensor::WriteRegister` method is the preferred method to write to a register. 
The fields in each :class:`~VNSDK::Registers::ConfigRegister` use `Nullable <https://learn.microsoft.com/en-us/dotnet/api/system.nullable-1?view=net-8.0>`_ and have no default values.
Each field in a :class:`~VNSDK::Registers::ConfigRegister` object must be populated before it can be used to write to the sensor.

To write to a sensor, you must

   #. Create a :class:`~VNSDK::Registers::ConfigRegister` object 
   #. Populate the :class:`~VNSDK::Registers::ConfigRegister` object with the desired values to configure the unit
   #. Call the :func:`~VNSDK::Sensor::WriteRegister` method

.. tab:: C#

   .. literalinclude:: ../../../cs/examples/GettingStarted/GettingStarted.cs
      :language: c#
      :start-at: VNSDK.Registers.System.AsyncOutputType
      :end-at: Console.WriteLine("ADOR configured.");
      :dedent: 12

.. tab:: MATLAB

   .. literalinclude:: ../../../matlab/examples/GettingStarted/GettingStarted.m
      :language: matlab
      :start-at: Registers.System.AsyncOutputType();
      :end-at: disp("ADOF configured.")

.. tip::
   To ensure register values are not unintentionally changed, it is reccomended to first read a register, change only the desired parameter, and write the register back to the unit. 
   
   .. tab:: C#

      .. code-block:: csharp

         VNSDK.Registers.System.SyncControl syncControlReg = new VNSDK.Registers.System.SyncControl();
         try 
         { 
            sensor.ReadRegister(syncControlReg); 
            syncControlReg.syncOutMode = VNSDK.Registers.System.SyncControl.SyncOutMode.ImuStart;
            syncControlReg.syncOutSkipFactor = 8;
            sensor.WriteRegister(syncControlReg);
         }
         catch (Exception latestError)
         {
               Console.WriteLine($"Error: {latestError.Message} encountered when reading & writing to SyncControl Register.");
               return 1;
         }

   .. tab:: MATLAB

      .. code-block:: matlab
         
         syncControlReg = VNSDK.Registers.System.SyncControl();
         try 
            sensor.ReadRegister(syncControlReg); 
            syncControlReg.syncOutMode = VNSDK.Registers.System.SyncControl.SyncOutMode.ImuStart;
            syncControlReg.syncOutSkipFactor = 8;
            sensor.WriteRegister(syncControlReg);
         catch latestError
               error('Error encountered when reading register SyncControl Register.\n%s\n', latestError.message);
         end

Reading Measurements
====================
By default, all asynchronous measurements (except *gnssSatInfo* and *gnssRawMeas*), whether sourced from ASCII or binary outputs, are made available as a :class:`~VNSDK::CompositeData` object on the ``MeasurementQueue`` contained within the :class:`~VNSDK::Sensor` object once the packet is parsed.

The Composite Data Object
-------------------------
A :class:`~VNSDK::CompositeData` object contains each measurement group (e.g. `Attitude`) as public members, each of which is a structure containing each measurement type (e.g. `Ypr`). Exactly one :class:`~VNSDK::CompositeData` object is populated for each measurement message, each of which contains a subset of the possible measurement types. Because a measurement message likely does not contain each enabled measurement, the measurement type members are each a `std::optional <https://en.cppreference.com/w/cpp/utility/optional>`_ of the underlying datatypes defined in the unit's `ICD <https://www.vectornav.com/resources/technical-documentation/interface-control-documents>`_. 

.. For example, `accel` is documented in the ICD in the `Imu` measurement group and is a ``Vec3f``. As such, it can be accessed in a :class:`~VNSDK::CompositeData` object as: ADD EXAMPLE HERE

.. note::
   The :class:`~VNSDK::CompositeData` class does not contain the `Common` group. As such, any measurement types populated via a binary measurement in the `Common` group will show up in the underlying group. For example, a binary message which contains `ypr` from the `Common` group will be populated in the ``attitude`` member of a :class:`~VNSDK::CompositeData` object.

.. caution::
   For variable length outputs *gnssSatInfo* and *gnssRawMeas*, :class:`~VNSDK::CompositeData` stores as many entries as its internal buffer allows for those outputs (``GNSS_SAT_INFO_MAX_COUNT`` or ``GNSS_RAW_MEAS_MAX_COUNT`` respectively). These packets contain a count field (`numSats` or `numMeas` respectively) with the number of valid measurements output by the sensor for that packet.  If the count field value exceeds the storage capacity, the buffer will be filled, but the `numSats` field will remain unchanged from the value output by the sensor. To iterate through valid measurements without exceeding array bounds, users should never exceed the minimum of the count field and the internal buffer size (eg. ``min(numSats,GNSS_SAT_INFO_MAX_COUNT)``).

How to Read a Measurement
-------------------------

#. Get a :class:`~VNSDK::CompositeData` object from the ``MeasurementQueue``.

   This can be done in two ways:

   * Use :func:`~VNSDK::Sensor::GetNextMeasurement`, which will block until the set timeout. If there is already a :class:`~VNSDK::CompositeData` object on the queue when called, it will return that object without blocking.
   * Use :func:`~VNSDK::Sensor::GetMostRecentMeasurement`
   
   Both of these methods return a `std::optional <https://en.cppreference.com/w/cpp/utility/optional>`_, which means that you must check to ensure that the returned value is populated using the `has_value <https://en.cppreference.com/w/cpp/utility/optional/operator_bool>`_ method. 

#. Validate that the measurement you want is in the :class:`~VNSDK::CompositeData` object. This can be done in two ways:

   * Use the :func:`~VNSDK::CompositeData::MatchesMessage` method
      This method checks to see which message populated this particular composite data object, using an exact match. If a composite data object matches a particular header or message, each included measurement type is guaranteed to have a value, so you can safely call `value() <https://en.cppreference.com/w/cpp/utility/optional/value>`_.
      
      This approach is especially useful if you are sending measurements via multiple output registers at once, and would like to take different actions for each one.

      .. As shown in the above example, 

      The :func:`~VNSDK::CompositeData::MatchesMessage` method can accept either a string literal in the case of ASCII messages, or the :class:`~VNSDK::Registers::System::BinaryOutput` object we used earlier to configure the register in the case of a binary message.

   * Use the `has_value <https://en.cppreference.com/w/cpp/utility/optional/operator_bool>`_ method on each measurement you're interested in.
      Each measurement type of the :class:`~VNSDK::CompositeData` object is a `std::optional <https://en.cppreference.com/w/cpp/utility/optional>`_, so you can directly check if the value has been set by using `has_value <https://en.cppreference.com/w/cpp/utility/optional/operator_bool>`_. 
      This is most useful if you do not necessarily know or care from which message a particular measurement came, and would like to perform some action whenever a measurement is available.

      .. To achieve a similar result, the Measurement Matches Message example could instead be written as: Add EXAMPLE HERE

#. Access measurement value
   Now that we know the measurement has a value, we can safely access the underlying measurement value. This can be done with the ``value`` call. 
   
   .. as:

Receiving Composite Data
-------------------------

.. tab:: C#

   .. literalinclude:: ../../../cs/examples/GettingStarted/GettingStarted.cs
      :language: c#
      :start-at: while
      :end-before: t0.Stop();
      :dedent: 12
   
.. tab:: MATLAB

   .. literalinclude:: ../../../matlab/examples/GettingStarted/GettingStarted.m
      :language: matlab
      :start-at: while
      :end-before: %% 7.

Sending Commands
================
Each command able to be sent to the unit is available as a public method of the :class:`~VNSDK::Sensor` class using blocking calls.

To send a command, simply call the public method with the necessary parameters, if applicable. For example, to send a :func:`~VNSDK::Sensor::SetInitialHeading` command, you can call

.. tab:: C#

   .. code-block:: C#

      sensor.SetInitialHeading(45);

.. tab:: MATLAB

   .. code-block:: matlab

      sensor.SetInitialHeading(45);


Error Handling
==============

To ensure robustness in the event of an error, it is important to understand how errors are exposed to the user and the type of error handling required.Errors can be generated either synchronously—a direct result of a user call—or asynchronously—occurring independent of a user call. The VNSDK C++ library does not throw exceptions; it instead returns error codes which are propagated to the CLI code and thrown natively in C# or MATLAB. Because of this, all exceptions can be caught as native C# or MATLAB exceptions.

Synchronous Errors
------------------

Synchronous errors are classified as errors that result from a function call that can raise an exception. All user-facing functions in the Sensor class will throw unless otherwise specified. This means synchronous errors will terminate the program by default unless appropriate error handling is provided. As an example, consider a connect routine is needed that will wait for a USB device to be plugged in on a specific COM port before proceeding:


.. tab:: C#

   .. code-block:: C#

      while (true)
      {
          try
          {
              Console.Write($"Attempting to connect to {COM_PORT} ...");
              System.Threading.Thread.Sleep(2000); // sleep for two seconds
              sensor.Connect(COM_PORT, VNSDK.Sensor.BaudRate.Baud115200);
              break;
          }
          catch (Exception e)
          {
              Console.WriteLine(e);
          }
      }
      Console.WriteLine("connected");

.. tab:: MATLAB

   .. code-block:: matlab

      while ~connected
          try
              fprintf('Attempting to connect to %s ...', COM_PORT);
              pause(2); % sleep for 2 seconds
              sensor.Connect(COM_PORT, VNSDK.Sensor.BaudRate.Baud115200);
          catch e
              fprintf('\n%s\n', e.message);
          end
      end

      disp('connected');

.. The VNSDK also supports error handling for non-blocking commands. For more information, please reference :ref:`pages/AdvancedFunctionality:Non-Blocking Commands`

Asynchronous Errors
-------------------
Asynchronous errors are classified as errors that are not associated with a function call and can occur at any time. To handle such errors, the VNSDK provides a :func:`~VNSDK::Sensor::ThrowIfAsyncError` function, that throws an exception if an error is on the asynchronous error queue. This queue should be monitored periodically to ensure proper error handling. For example, if data has not been received in an expected period of time, checking the error queue may reveal a sensor Hard Fault which would require the sensor to be reset.

.. tab:: C#

   .. code-block:: C#

      try
      {
          sensor.ThrowIfAsyncError();
      }
      catch (Exception asyncError)
      {
        // Handle asynchronous error
      }

.. tab::  MATLAB

    .. code-block::  matlab
        
      try
          sensor.ThrowIfAsyncError();
      catch asyncError
          % Handle asynchronous error
      end


