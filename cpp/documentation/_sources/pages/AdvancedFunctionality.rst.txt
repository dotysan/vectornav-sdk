Advanced Functionality
######################


Non-Blocking Commands
=====================
In some cases, it is necessary to send commands without blocking, perform other operations, and later return to validate the unit's response. This is what the generic :func:`~VN::Sensor::sendCommand` method is for. To do so:
   #. Create the :class:`~VN::GenericCommand` object that we would like to send to the unit

      .. literalinclude:: ../../examples/NonBlockingCommands/main.cpp
         :language: c++
         :start-at: KnownMagneticDisturbance kmd(KnownMagneticDisturbance::State::Present);
         :end-at: KnownMagneticDisturbance kmd(KnownMagneticDisturbance::State::Present);
         :dedent: 4

   #. Call the :func:`~VN::Sensor::sendCommand` method with our :class:`~VN::GenericCommand` object and the waitMode specified as :enumerator:`~VN::Sensor::SendCommandBlockMode::None`

      .. literalinclude:: ../../examples/NonBlockingCommands/main.cpp
         :language: c++
         :start-at: latestError = sensor.sendCommand(&kmd, Sensor::SendCommandBlockMode::None);  // Non-blocking
         :end-at: latestError = sensor.sendCommand(&kmd, Sensor::SendCommandBlockMode::None);  // Non-blocking
         :dedent: 4

A full list of available commands can be found in :ref:`Commands.hpp <file_include_vectornav_Interface_Commands.hpp>`.

The command will then be sent to the unit and added to a queue, waiting for a corresponding response from the unit. When a command response (i.e. non-measurement ASCII packet) is seen from the unit, the response will attempt to be matched with the oldest command sent in the queue.
If the response matches, the function exits. If not, it will continue through the queue (popping each command from the queue) until either the response is matched to a command or the queue is empty. This is done because VectorNav units always respond to commands in the order in which they were received. Any synchronous VnError is considered a valid response to any command.  Commands are also removed from the queue if the removal timeout length (:member:`~VN::Config::CommandProcessor::commandRemovalTimeoutLength`) is reached.

.. caution::
   The :class:`~VN::CommandProcessor` has limited queue capacity. Excessive rapid command submission may result in dropped commands.  Significantly increasing the queue capacity may prevent such drops, but risks overflowing the serial output buffer or the sensor's input buffer.

.. caution::
   The system validates commands only up to a specified validation length (command prefix). This can lead to command misidentification where the system incorrectly reports which command failed. This can occur under the following circumstances:
   
   * Multiple commands with identical prefixes are sent within the removal timeout length.
   * A command is dropped while a subsequent similar command succeeds

   Potential command identification errors must be handled by user's error processing logic.

When you are ready to check the unit's response, you can do so using :func:`~VN::GenericCommand::getResponse`;

.. literalinclude:: ../../examples/NonBlockingCommands/main.cpp
   :language: c++
   :start-at: std::cout << "KMD Response: " << kmd.getResponse() << std::endl;
   :end-at: std::cout << "KMD Response: " << kmd.getResponse() << std::endl;
   :dedent: 8

If the response is empty, a couple of things may be happening:
   * The command is still in the command queue, awaiting a response
      If this is the case, :func:`~VN::GenericCommand::isAwaitingResponse` will return ``true``. Whether a command is "awaiting a response" is not time-based; rather, it will be awaiting a response until any command response attempts to match with that command. As such, the correct action could either be to check again later (if only a brief period has elapsed) or to resend the command, assuming there was a communication failure.

      .. code-block:: cpp

         if (kmd.isAwaitingResponse()) {
            // The kmd command is still in the queue. It could either be too early to have heard a response, or this command should be resent.
         }

   * The command has received an invalid response
      In this case, a response has attempted to be matched with the :class:`~VN::GenericCommand` object. This likely means that the unit did not hear the command and was responding to a subsequent command. Most likely, we should try to resend the command.

Now that we know we have a valid response, we should make sure the response is not a VnError using :func:`~VN::GenericCommand::getError` (if the response is any VnError, the unit did not apply the command). 

.. literalinclude:: ../../examples/NonBlockingCommands/main.cpp
   :language: c++
   :start-at: std::optional<Error> error_maybe = kmd.getError();
   :end-at: }
   :dedent: 8

If the value returned from :func:`~VN::GenericCommand::getError` is empty, no error occurred and the command was accepted by the unit. If the value returned is not empty, the error can either be printed to a log using the ``<<`` operator or identified using :func:`~VN::errorCodeToString`. More information on handling errors can be found in :ref:`pages/KeyFunctionality:Error Handling`.

Because :func:`~VN::Sensor::readRegister` and :func:`~VN::Sensor::writeRegister` are simply specialized commands to the unit, sending the commands non-blocking is very similar to sending any other command non-blocking. The only additional step is the conversion between the :class:`~VN::Register` object and the :class:`~VN::GenericCommand` object.

Non-Blocking Read Register
--------------------------

Just like any other :func:`~VN::Sensor::readRegister` command, we first need to instantiate our :class:`~VN::Register` object.

.. literalinclude:: ../../examples/NonBlockingCommands/main.cpp
   :language: c++
   :start-at: Registers::VelocityAiding::VelAidingMeas velAidRegister;
   :end-at: Registers::VelocityAiding::VelAidingMeas velAidRegister;
   :dedent: 4

We then can produce a :class:`~VN::GenericCommand` object for the *Read Register* command using the :func:`~VN::Register::toReadCommand` method.

.. code-block:: c++

   GenericCommand velAidRRGCommand = velAidRegister.toReadCommand();

Now that we have a :class:`~VN::GenericCommand` object, we can send it non-blocking using the steps in :ref:`pages/AdvancedFunctionality:Non-Blocking Commands`. After checking for a response and ensuring the response is valid, we can repopulate the original :class:`~VN::Register` object fields using :func:`~VN::Register::fromCommand`.

.. code-block:: c++

   bool errorOccured = velAidRegister.fromCommand(velAidRRGCommand);

Assuming the command received a non-error, valid response, the fields of ``velAidRegister`` are now populated with the values from the VectorNav unit, and we can access them as normal members of the object.

Non-Blocking Write Register
---------------------------

Writing a register without blocking is very similar to reading a register without blocking. The only difference is the method called to create the *Write Register* command rather than the *Read Register* command.

Very similar to the first step in :ref:`pages/KeyFunctionality:Writing Registers`, we create our :class:`~VN::Register` object, populating it with the desired configuration values.

.. literalinclude:: ../../examples/NonBlockingCommands/main.cpp
   :language: c++
   :start-at: Registers::VelocityAiding::VelAidingMeas velAidRegister;
   :end-at: velAidRegister.velocityZ = 0.0f;
   :dedent: 4

We then can produce a :class:`~VN::GenericCommand` object for the *Write Register* command using the :func:`~VN::ConfigurationRegister::toWriteCommand` method.

.. literalinclude:: ../../examples/NonBlockingCommands/main.cpp
   :language: c++
   :start-at: std::optional<GenericCommand> velAidWRGCmdOpt = velAidRegister.toWriteCommand();
   :end-at: std::optional<GenericCommand> velAidWRGCmdOpt = velAidRegister.toWriteCommand();
   :dedent: 4

Now that we have our :class:`~VN::GenericCommand` object for the *Write Register* command, we can send it to the unit and validate acceptance following the steps in :ref:`pages/AdvancedFunctionality:Non-Blocking Commands`.

Subscribe to an Unparsed Packet
===============================
In some cases, it is desired to subscribe to specific measurement packets without using the :class:`~VN::CompositeData` object. For this, the :func:`~VN::Sensor::subscribeToMessage` method can be used. The interface we will use to receive the packets is a :type:`~VN::PacketQueue`, on which the :class:`~VN::Sensor` object will place any matching packet. The constructor requires a single argument of the queue capacity:

.. code-block:: c++
 
   PacketQueue PacketQueue(5);

Regardless of whether the full packet can be parsed, so long as the validated packet can be identified and the packet header meets the requirements of the specified filter, the packet will be placed on the registered queue.

To unsubscribe from a message, :func:`~VN::Sensor::unsubscribeFromMessage` can be used.

Subscribing to ASCII Measurement Packets
----------------------------------------

For ASCII measurement packets, we can define a filter using the enums provided in :type:`~VN::Sensor::AsciiSubscriberFilterType` (aliased from :enum:`~VN::AsciiPacketDispatcher::SubscriberFilterType`)

For example, if we would like to subscribe to the *VNINS* message, we can use the following call:

.. code-block:: c++

   sensor.subscribeToMessage(&PacketQueue, "VNINS", Sensor::AsciiSubscriberFilterType::StartsWith);

or, if we would like to subscribe to any NMEA message (that is, any message whose header does not begin with VN), we can use the following call:

.. code-block:: c++

   sensor.subscribeToMessage(&PacketQueue, "VN", Sensor::AsciiSubscriberFilterType::DoesNotStartWith);

A maximum of :member:`~VN::Config::PacketDispatchers::asciiPacketSubscriberCapacity` ASCII packet filters can be registered concurrently.

Subscribing to Binary Measurement Packets
-----------------------------------------
For a binary measurement, we can define a filter using the enums provided in :type:`~VN::Sensor::FaSubscriberFilterType` (aliased from :enum:`~VN::FaPacketDispatcher::SubscriberFilterType`)

A maximum of :member:`~VN::Config::PacketDispatchers::faPacketSubscriberCapacity` binary packet filters can be registered concurrently.

Receiving Unparsed Bytes
========================
Most applications are only interested in validated packets, received either as command responses or as measurements in a :class:`~VN::CompositeData` object. 
Although validated packets are sufficient in most uses, the VNSDK also includes the ability to receive and log all bytes.
This section details how to receive bytes from the unit which are not necessarily part of any known packet.

All Received Bytes
------------------
It is possible to receive all bytes received from the unit. The most common application for this is to log each byte to a file. Because we don't want to bottleneck the packet finding and measurement parsing occurring on the *listening thread* with any possible File I/O, we need to provide an output buffer to the :class:`~VN::Sensor` object, using which we can access the bytes of interest.

We first create a :class:`~VN::ByteBuffer` object of the appropriate size, then register it with the :class:`~VN::Sensor` object using :func:`~VN::Sensor::registerReceivedByteBuffer`. All subsequent received bytes will be placed on that queue, to be read when necessary.

.. code-block:: c++

   ByteBuffer receivedByteBuffer(4096 * 2);
   sensor.registerReceivedByteBuffer(&receivedByteBuffer);

When we would like our byte buffer to cease being populated, we can deregister the buffer using the :func:`~VN::Sensor::deregisterReceivedByteBuffer` method.

.. code-block:: c++

   sensor.deregisterReceivedByteBuffer();

Only one byte buffer at a time can be registered for all received bytes.

Skipped Bytes
-------------

A skipped byte is any byte received by the :class:`~VN::Sensor` object that is not part of a valid packet. 
Logging this can be useful when identifying dropped packets due to hardware noise, or when using an experimental message type that is unsupported by the SDK. 

Very similar to registering a received a measurement packet, we need to instantiate and register a :type:`~VN::PacketQueue` object as the interface to access the skipped bytes using :func:`~VN::Sensor::subscribeToMessage`. We can do this using

.. code-block:: c++

   PacketQueue skippedByteQueue(5);
   sensor.subscribeToMessage(&skippedByteQueue, SyncByte::None)

and can later deregister this buffer using the :func:`~VN::Sensor::unsubscribeFromMessage` method:

.. code-block:: c++

   sensor.unsubscribeFromMessage(&skippedByteQueue);

Only one byte buffer at a time can be registered for skipped bytes.

Receiving Unexpected ASCII Messages
===================================
As discussed in :ref:`pages/AdvancedFunctionality:Non-Blocking Commands`, each outgoing command (whether set to blocking or not) is placed in a queue to await a response. Any non-measurement, valid ASCII messages from the unit that is not expected by a command in that queue will be placed on the ``AsyncErrorQueue``. In most cases, this will include asynchronous VnError messages, defined following :enum:`~VN::Error` as 

* :enumerator:`~VN::Error::HardFault`
* :enumerator:`~VN::Error::WatchdogReset`
* :enumerator:`~VN::Error::OutputBufferOverflow`
* :enumerator:`~VN::Error::ErrorBufferOverflow`

In rare cases, a message can be placed on this queue because of hardware noise. It is possible the unit received (and is responding to) a command that was not sent by the SDK or that the response message was corrupted in reception, but remained a valid packet by the CRC check. For robustness, it is best to monitor the ``AsyncErrorQueue`` for any valid but unexpected non-measurement ASCII messages received from the unit. The ``AsyncErrorQueue`` can be accessed by :func:`~VN::Sensor::getNextAsyncError` and ``AsyncErrorQueue``.

.. FB Packets
.. ==========
 .. warning::
..    Todo

Debugging
=========
The file :ref:`Debug.hpp <file_include_vectornav_Debug.hpp>` contains helpful macros for SDK debug logging. Standard debugging is available in two levels, each with their own macro (``VN_DEBUG_1``, ``VN_DEBUG_2``) that are called upon various SDK events but are disabled by default. The debug messages default to off (``0``) but can be enabled by setting ``CURRENT_VN_DEBUG_LEVEL`` to the desired level.
In addition, ``VN_ASSERT`` and ``VN_ABORT`` are provided to output the filename and line number on which an assert failed, or an abort is called.

.. caution:: 
   While ``VN_DEBUG`` can be helpful for debugging, high-rate measurement data often induces latency due to the speed of ``std::cout``, introducing a new issue. In this case, it may be beneficial to instead add each received debug message to a :class:`~VN::Vector` and output every message together in batches, or at the end of the test.
   This can be accomplished using ``VN_LIGHTWEIGHT_DEBUG``.
