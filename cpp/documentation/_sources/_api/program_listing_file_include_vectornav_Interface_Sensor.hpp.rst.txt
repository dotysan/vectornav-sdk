
.. _program_listing_file_include_vectornav_Interface_Sensor.hpp:

Program Listing for File Sensor.hpp
===================================

|exhale_lsh| :ref:`Return to documentation for file <file_include_vectornav_Interface_Sensor.hpp>` (``include\vectornav\Interface\Sensor.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #ifndef VN_SENSOR_HPP_
   #define VN_SENSOR_HPP_
   
   #include <array>
   #include <atomic>
   #include <memory>
   #include <optional>
   
   #include "vectornav/Config.hpp"
   #include "vectornav/HAL/File.hpp"
   #include "vectornav/HAL/Serial.hpp"
   #include "vectornav/HAL/Serial_Base.hpp"
   #include "vectornav/HAL/Thread.hpp"
   #include "vectornav/HAL/Timer.hpp"
   #include "vectornav/Implementation/AsciiHeader.hpp"
   #include "vectornav/Implementation/AsciiPacketDispatcher.hpp"
   #include "vectornav/Implementation/CommandProcessor.hpp"
   #include "vectornav/Implementation/FaPacketDispatcher.hpp"
   #include "vectornav/Implementation/FbPacketDispatcher.hpp"
   #include "vectornav/Implementation/MeasurementDatatypes.hpp"
   #include "vectornav/Implementation/PacketSynchronizer.hpp"
   #include "vectornav/Implementation/QueueDefinitions.hpp"
   #include "vectornav/Interface/Commands.hpp"
   #include "vectornav/Interface/Errors.hpp"
   #include "vectornav/Interface/GenericCommand.hpp"
   #include "vectornav/Interface/Registers.hpp"
   
   namespace VN
   {
   
   class SensorTestHarness;
   
   class Sensor
   {
   public:
   
       enum class MeasQueueMode : uint8_t
       {
           Off = 0,
           Force = static_cast<uint8_t>(MeasurementQueue::PutMode::Force),
           Try = static_cast<uint8_t>(MeasurementQueue::PutMode::Try),
   #if THREADING_ENABLE
           Retry = static_cast<uint8_t>(MeasurementQueue::PutMode::Retry)
   #endif
       };
   
       // ------------------------------------------
       // ------------------------------------------
       Sensor(MeasQueueMode mode = MeasQueueMode::Force);
   
       template <size_t MainByteBufferCapacity, size_t FbByteBufferCapacity>
       Sensor(std::array<uint8_t, MainByteBufferCapacity>& mainBuffer, std::array<uint8_t, FbByteBufferCapacity>& fbBuffer,
              MeasQueueMode mode = MeasQueueMode::Force);
   
       ~Sensor();
   
       // ------------------------------------------
       // ------------------------------------------
   
       using BaudRate = Registers::System::BaudRate::BaudRates;
   
       Error connect(const Serial_Base::PortName& portName, const BaudRate baudRate) noexcept;
   
       Error connect(const Filesystem::FilePath& fileName) noexcept;
   
       Error autoConnect(const Serial_Base::PortName& portName) noexcept;
   
       bool verifySensorConnectivity() noexcept;
   
       Error autoBaud() noexcept;
   
       std::optional<Serial_Base::PortName> connectedPortName() const noexcept { return _serial.connectedPortName(); };
   
       std::optional<BaudRate> connectedBaudRate() const noexcept
       {
           auto connectedBaudRate = _serial.connectedBaudRate();
           return connectedBaudRate ? std::make_optional(static_cast<BaudRate>(*connectedBaudRate)) : std::nullopt;
       };
   
       // @brief Changes the baud rate on a specified serial port of the sensor. If the targeted port is the currently active one, it also updates the host's baud
       // rate to match.  Will retry on failure
       Error changeBaudRate(const BaudRate newBaudRate,
                            Registers::System::BaudRate::SerialPort serialPort = Registers::System::BaudRate::SerialPort::ActiveSerial) noexcept;
   
       Error changeHostBaudRate(const BaudRate newBaudRate) noexcept;
   
       void disconnect() noexcept;
   
       // ------------------------------------------
       // ------------------------------------------
   
       using CompositeDataQueueReturn = DirectAccessQueue_Interface<CompositeData>::value_type;
   
       bool hasMeasurement() const noexcept { return !_measurementQueue.isEmpty(); }
   
       CompositeDataQueueReturn getNextMeasurement(const bool block = true) noexcept;
   
       CompositeDataQueueReturn getMostRecentMeasurement(const bool block = true) noexcept;
   
       // ------------------------------------------
       // ------------------------------------------
   
       enum class SendCommandBlockMode
       {
           None,            
           Block,           
           BlockWithRetry,  
       };
   
       Error readRegister(Register* registerToRead, const bool retryOnFailure = true) noexcept;
   
       Error writeRegister(ConfigurationRegister* registerToWrite, const bool retryOnFailure = true) noexcept;
   
       Error writeSettings() noexcept;
   
       Error reset() noexcept;
   
       Error restoreFactorySettings() noexcept;
   
       Error knownMagneticDisturbance(const KnownMagneticDisturbance::State state) noexcept;
   
       Error knownAccelerationDisturbance(const KnownAccelerationDisturbance::State state) noexcept;
   
       Error setInitialHeading(const float heading) noexcept;
       Error setInitialHeading(const Ypr& ypr) noexcept;
       Error setInitialHeading(const Quat& quat) noexcept;
   
       Error asyncOutputEnable(const AsyncOutputEnable::State state) noexcept;
   
       Error setFilterBias() noexcept;
   
       Error setBootloader(const SetBootLoader::Processor processorId) noexcept;
   
       Error sendCommand(GenericCommand* commandToSend, SendCommandBlockMode waitMode, const Microseconds waitLength = Config::Sensor::commandSendTimeoutLength,
                         const Microseconds timeoutThreshold = Config::CommandProcessor::commandRemovalTimeoutLength) noexcept;
   
       Error serialSend(const char* buffer, size_t len) noexcept;
   
       // ------------------------------------------
       // ------------------------------------------
   
       void registerReceivedByteBuffer(ByteBuffer* const receivedByteBuffer) noexcept;
   
       void deregisterReceivedByteBuffer() noexcept;
   
       using SyncByte = PacketDetails::SyncByte;
       using AsciiSubscriberFilterType = AsciiPacketDispatcher::SubscriberFilterType;
       using FaSubscriberFilterType = FaPacketDispatcher::SubscriberFilterType;
       using Fb00SubscriberFilter = FbPacketDispatcher::SubscriberFilter;
       using BinaryOutputMeasurements = Registers::System::BinaryOutputMeasurements;
   
       Error subscribeToMessage(PacketQueue_Interface* queueToSubscribe, const SyncByte syncByte) noexcept;
   
       Error subscribeToMessage(PacketQueue_Interface* queueToSubscribe, const BinaryOutputMeasurements& binaryOutputMeasurementFilter,
                                const FaSubscriberFilterType filterType = FaSubscriberFilterType::ExactMatch) noexcept;
   
       Error subscribeToMessage(PacketQueue_Interface* queueToSubscribe, const AsciiHeader& asciiHeaderFilter,
                                const AsciiSubscriberFilterType filterType = AsciiSubscriberFilterType::StartsWith) noexcept;
   
       Error subscribeToMessage(PacketQueue_Interface* queueToSubscribe, const Fb00SubscriberFilter fb00Filter) noexcept;
   
       void unsubscribeFromMessage(PacketQueue_Interface* queueToUnsubscribe, const SyncByte syncByte) noexcept;
   
       void unsubscribeFromMessage(PacketQueue_Interface* queueToUnsubscribe, const BinaryOutputMeasurements& filter) noexcept;
   
       void unsubscribeFromMessage(PacketQueue_Interface* queueToUnsubscribe, const AsciiHeader& filter) noexcept;
   
       // ------------------------------------------
       // ------------------------------------------
   #if (!THREADING_ENABLE)
   
       Error loadMainBufferFromSerial() noexcept;
   
       Error loadMainBufferFromFile() noexcept;
   
       Errored processNextPacket() noexcept;
   #endif
   
       friend class SensorTestHarness;
   
       // -------------------------------
       // -------------------------------
   
       uint16_t asyncErrorQueueSize() const noexcept { return _asyncErrorQueue.size(); }
   
       std::optional<AsyncError> getNextAsyncError() noexcept { return _asyncErrorQueue.get(); }
   
       void clearAsyncErrorQueue() noexcept { _asyncErrorQueue.reset(); }
   
   private:
       //-------------------------------
       // Connectivity
       //-------------------------------
       ByteBuffer _mainByteBuffer{Config::PacketFinders::mainBufferCapacity};
       Serial _serial{_mainByteBuffer};
       InputFile _file{false};
   
       enum class ConnectionType
       {
           None,
           Serial,
           File
       };
       ConnectionType _connectionType = ConnectionType::None;
   
   #if (THREADING_ENABLE)
       std::atomic<bool> _listening = false;
       std::unique_ptr<Thread> _listeningThread = nullptr;
       void _listen() noexcept;
       Error loadMainBufferFromSerial() noexcept;
       Error loadMainBufferFromFile() noexcept;
       Errored processNextPacket() noexcept;
       void _startListening() noexcept;
       void _stopListening() noexcept;
       mutable Mutex _sensorMutex;
   #endif
   
       // -------------------------------
       // Measurement Operators
       // -------------------------------
       MeasurementQueue _measurementQueue{MeasurementQueue::PutMode::Force, Config::PacketDispatchers::compositeDataQueueCapacity};
       Sensor::CompositeDataQueueReturn _blockOnMeasurement(Timer& timer, const Microseconds sleepLength) noexcept;
   
       //-------------------------------
       // Command Operators
       //-------------------------------
       CommandProcessor _commandProcessor{[this](AsyncError&& error) { _asyncErrorQueue.put(std::move(error)); }};
       Error _blockOnCommand(GenericCommand* commandToWait, Timer& timer) noexcept;
   
       // -------------------------------
       // Packet Processing
       // -------------------------------
       MeasQueueMode _measQueueMode;
       bool _parseToCD;
       FaPacketDispatcher _faPacketDispatcher{&_measurementQueue, Config::PacketDispatchers::cdEnabledMeasTypes, _parseToCD};
       AsciiPacketDispatcher _asciiPacketDispatcher{&_measurementQueue, Config::PacketDispatchers::cdEnabledMeasTypes, &_commandProcessor, _parseToCD};
       FbPacketDispatcher _fbPacketDispatcher{&_faPacketDispatcher, Config::PacketFinders::fbBufferCapacity};
   
       PacketSynchronizer _packetSynchronizer{_mainByteBuffer, [this](AsyncError&& error) { _asyncErrorQueue.put(std::move(error)); }};
   
       ByteBuffer* _receivedByteBuffer = nullptr;
       void _copyToReceivedByteBuffer(size_t mainBufferIndex) noexcept;
       // -------------------------------
       // Error handling
       // -------------------------------
   
       Queue_Mutexed<AsyncError, Config::Errors::asyncErrorQueueCapacity> _asyncErrorQueue{};
   };
   
   template <size_t MainByteBufferCapacity, size_t FbBufferCapacity>
   Sensor::Sensor(std::array<uint8_t, MainByteBufferCapacity>& mainBuffer, std::array<uint8_t, FbBufferCapacity>& fbBuffer, MeasQueueMode mode)
       : _mainByteBuffer(mainBuffer.data(), mainBuffer.size()),
         _measQueueMode{mode},
         _parseToCD{mode != MeasQueueMode::Off},
         _fbPacketDispatcher(&_faPacketDispatcher, fbBuffer.data(), fbBuffer.size())
   {
       // Set up packet synchronizer
       _packetSynchronizer.addDispatcher(&_faPacketDispatcher);
       _packetSynchronizer.addDispatcher(&_asciiPacketDispatcher);
       _packetSynchronizer.addDispatcher(&_fbPacketDispatcher);
       if (_parseToCD) { _measurementQueue.setPutMode(static_cast<MeasurementQueue::PutMode>(_measQueueMode)); }
   }
   }  // namespace VN
   
   #endif  // VN_SENSOR_HPP_
