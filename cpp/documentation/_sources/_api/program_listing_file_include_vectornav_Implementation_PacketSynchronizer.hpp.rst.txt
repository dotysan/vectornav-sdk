
.. _program_listing_file_include_vectornav_Implementation_PacketSynchronizer.hpp:

Program Listing for File PacketSynchronizer.hpp
===============================================

|exhale_lsh| :ref:`Return to documentation for file <file_include_vectornav_Implementation_PacketSynchronizer.hpp>` (``include\vectornav\Implementation\PacketSynchronizer.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #ifndef VN_PACKETSYNCHRONIZER_HPP_
   #define VN_PACKETSYNCHRONIZER_HPP_
   
   #include <cstdint>
   #include <functional>
   
   #include "vectornav/Config.hpp"
   #include "vectornav/Implementation/PacketDispatcher.hpp"
   #include "vectornav/Implementation/QueueDefinitions.hpp"
   #include "vectornav/Interface/Errors.hpp"
   #include "vectornav/TemplateLibrary/ByteBuffer.hpp"
   #include "vectornav/TemplateLibrary/Vector.hpp"
   
   namespace VN
   {
   
   constexpr uint8_t PACKET_PARSER_CAPACITY = Config::PacketFinders::maxNumPacketFinders;
   
   class PacketSynchronizer
   {
   public:
       using AsyncErrorQueuePush = std::function<void(AsyncError&&)>;
   
       PacketSynchronizer(ByteBuffer& byteBuffer, AsyncErrorQueuePush asyncErrorQueuePush = nullptr, size_t packetMax = Config::PacketFinders::packetMaxLength)
           : _primaryByteBuffer(byteBuffer), _asyncErrorQueuePush{asyncErrorQueuePush}, _packetMaxLength(packetMax)
       {
       }
       Errored addDispatcher(PacketDispatcher* packetParser) noexcept;
   
       Errored dispatchNextPacket() noexcept;
   
       Error registerSkippedByteQueue(PacketQueue_Interface* const skippedByteQueue) noexcept
       {
           if (skippedByteQueue == nullptr) { return Error::PacketQueueNull; }
           _pSkippedByteQueue = skippedByteQueue;
           return Error::None;
       };
       void deregisterSkippedByteQueue() noexcept { _pSkippedByteQueue = nullptr; };
   
       using SyncBytes = Vector<uint8_t, SYNC_BYTE_CAPACITY>;
   
       size_t getValidPacketCount(const SyncBytes& syncByte) const noexcept;
       size_t getInvalidPacketCount(const SyncBytes& syncByte) const noexcept;
       size_t getSkippedByteCount() const noexcept { return _skippedByteCount; }
       size_t getReceivedByteCount() const noexcept { return _receivedByteCount; }
   
   private:
       struct InternalItem
       {
           PacketDispatcher* packetDispatcher = nullptr;
           SyncBytes syncBytes{};
           PacketDispatcher::FindPacketRetVal latestRetVal{};
           mutable size_t numValidPackets = 0;
           mutable size_t numInvalidPackets = 0;
       };
   
       Error _copyToSkippedByteQueueIfEnabled(const size_t numBytesToCopy) const noexcept;
   
       Vector<InternalItem, PACKET_PARSER_CAPACITY> _dispatchers{};
   
       mutable uint64_t _skippedByteCount = 0;
       PacketQueue_Interface* _pSkippedByteQueue = nullptr;
       mutable uint64_t _receivedByteCount = 0;
   
       ByteBuffer& _primaryByteBuffer;
       uint64_t _prevByteBufferSize = 0;
       size_t _prevBytesRequested = 0;
       PacketDispatcher::FindPacketRetVal::Validity _prevValidity = PacketDispatcher::FindPacketRetVal::Validity::Invalid;
       AsyncErrorQueuePush _asyncErrorQueuePush = nullptr;
       const size_t _packetMaxLength;
   };
   }  // namespace VN
   
   #endif  // VN_PACKETSYNCHRONIZER_HPP_
