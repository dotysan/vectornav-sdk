
.. _program_listing_file_include_vectornav_Implementation_DynamicPacketQueue.hpp:

Program Listing for File DynamicPacketQueue.hpp
===============================================

|exhale_lsh| :ref:`Return to documentation for file <file_include_vectornav_Implementation_DynamicPacketQueue.hpp>` (``include\vectornav\Implementation\DynamicPacketQueue.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #ifndef VN_DYNAMICPACKETQUEUE_HPP_
   #define VN_DYNAMICPACKETQUEUE_HPP_
   
   #include <deque>
   #include <mutex>
   #include <optional>
   
   #include "vectornav/Implementation/Packet.hpp"
   #include "vectornav/Implementation/QueueDefinitions.hpp"
   #include "vectornav/TemplateLibrary/DirectAccessQueue.hpp"
   
   namespace VN
   {
   class DynamicPacketQueue : public PacketQueue_Interface
   {
   public:
       using Element = typename DirectAccessQueue_Interface<Packet>::Element;
       using OwningPtr = typename DirectAccessQueue_Interface<Packet>::OwningPtr;
   
       DynamicPacketQueue(uint16_t packetLen) : _packetLen(packetLen) {};
   
       OwningPtr put() noexcept override
       {
           std::lock_guard<std::mutex> lock(_mutex);
           _clearFront();
           _queue.emplace_back(_packetLen);
           _queue.back().status = Element::Status::Putting;
           // std::cout << "putting " << &_queue.back() << std::endl;
           return OwningPtr(&_queue.back());
       }
   
       OwningPtr get() noexcept override
       {
           std::lock_guard<std::mutex> lock(_mutex);
           if (_queue.empty()) { return nullptr; }
           _clearFront();
           Element& frontElement = _queue.front();
           if (frontElement.status != Element::Status::InQueue) { return nullptr; }
   
           frontElement.status = Element::Status::Getting;
           return &frontElement;
       }
   
       OwningPtr getBack() noexcept override
       {
           std::lock_guard<std::mutex> lock(_mutex);
           if (_queue.empty()) { return nullptr; }
           return &_queue.back();
       }
   
       void reset() noexcept override
       {
           std::lock_guard<std::mutex> lock(_mutex);
           _queue.clear();
       }
   
       uint16_t size() const noexcept override
       {
           std::lock_guard<std::mutex> lock(_mutex);
           _clearFront();
           return static_cast<uint16_t>(_queue.size());
       }
   
       bool isEmpty() const noexcept override
       {
           std::lock_guard<std::mutex> lock(_mutex);
           _clearFront();
           return static_cast<uint16_t>(_queue.size()) == 0;
       }
   
       uint16_t capacity() const noexcept override { return static_cast<uint16_t>(_queue.max_size()); }
   
       void setPutMode(PutMode mode) noexcept override {}
   
   private:
       mutable std::deque<Element> _queue;  // Ignore const qualifier in size
       mutable std::mutex _mutex;
       uint16_t _packetLen = 0;
   
       void _clearFront() const
       {
           // I don't like this method...The better way is to register a callback with
           // owningPtr to pop front when released.
           while (!_queue.empty())
           {
               if (_queue.front().status == Element::Status::Free) { _queue.pop_front(); }
               else { break; }
           }
       }
   };
   }  // namespace VN
   
   #endif  // VN_DYNAMICPACKETQUEUE_HPP_
