
.. _program_listing_file_include_vectornav_Implementation_FbPacketDispatcher.hpp:

Program Listing for File FbPacketDispatcher.hpp
===============================================

|exhale_lsh| :ref:`Return to documentation for file <file_include_vectornav_Implementation_FbPacketDispatcher.hpp>` (``include\vectornav\Implementation\FbPacketDispatcher.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #ifndef VN_FBPACKETDISPATCHER_HPP_
   #define VN_FBPACKETDISPATCHER_HPP_
   
   #include <cstdint>
   
   #include "vectornav/Config.hpp"
   #include "vectornav/Implementation/BinaryHeader.hpp"
   #include "vectornav/Implementation/FaPacketDispatcher.hpp"
   #include "vectornav/Implementation/FbPacketProtocol.hpp"
   #include "vectornav/Implementation/PacketDispatcher.hpp"
   #include "vectornav/TemplateLibrary/ByteBuffer.hpp"
   
   namespace VN
   {
   
   class FbPacketDispatcher : public PacketDispatcher
   {
   public:
       FbPacketDispatcher(FaPacketDispatcher* faSubsciberInvoker, const size_t byteBufferCapacity)
           : PacketDispatcher({0xFB}), _faPacketDispatcher(faSubsciberInvoker), _fbByteBuffer(byteBufferCapacity)
       {
       }
   
       FbPacketDispatcher(FaPacketDispatcher* faSubsciberInvoker, uint8_t* bufferHead, size_t bufferCapacity)
           : PacketDispatcher({0xFB}), _faPacketDispatcher(faSubsciberInvoker), _fbByteBuffer(bufferHead, bufferCapacity)
       {
       }
   
       PacketDispatcher::FindPacketRetVal findPacket(const ByteBuffer& byteBuffer, const size_t syncByteIndex) noexcept override;
   
       Error dispatchPacket(const ByteBuffer& byteBuffer, const size_t syncByteIndex) noexcept override;
   
       struct SubscriberFilter
       {
           uint8_t packet : 1;
           uint8_t completedFaMessage : 1;
           uint8_t : 6;  // Resv
           SubscriberFilter() : packet(false), completedFaMessage(false) {}
           SubscriberFilter(const bool packet, const bool completedFaMessage) : packet(packet), completedFaMessage(completedFaMessage) {}
       };
   
       Error addSubscriber(PacketQueue_Interface* subscriber, SubscriberFilter filter) noexcept
       {
           if (subscriber == nullptr) { return Error::PacketQueueNull; }
           if (_subscribers.push_back(Subscriber{subscriber, filter})) { return Error::MessageSubscriberCapacityReached; }
           else { return Error::None; }
       }
   
       void removeSubscriber(PacketQueue_Interface* subscriberToRemove) noexcept
       {
           for (auto itr = _subscribers.begin(); itr != _subscribers.end();)
           {
               auto& subscriber = *itr;
               if (subscriberToRemove == subscriber.queueToPush) { itr = _subscribers.erase(itr); }
               else { ++itr; }
           }
       }
   
   private:
       void _resetFbBuffer() noexcept;
       void _addFaPacketCrc() noexcept;
       Error _moveBytesFromMainBufferToFbBuffer(FbPacketProtocol::Header splitPacketDetails, const ByteBuffer& byteBuffer, const uint16_t numOfBytesToMove,
                                                const size_t startingIndex) noexcept;
   
       FaPacketDispatcher* _faPacketDispatcher;
       ByteBuffer _fbByteBuffer;
       FbPacketProtocol::Metadata _latestPacketMetadata{};
       FbPacketProtocol::Metadata _previousPacketMetadata{};
   
       struct Subscriber
       {
           PacketQueue_Interface* queueToPush{nullptr};
           SubscriberFilter filter;
       };
       static const auto SUBSCRIBER_CAPACITY = 1;
       using Subscribers = Vector<Subscriber, SUBSCRIBER_CAPACITY>;
       Subscribers _subscribers;
   };
   }  // namespace VN
   
   #endif  // VN_FBPACKETDISPATCHER_HPP_
