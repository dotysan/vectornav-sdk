Key Functionality
#################

Establishing Communication
==========================

Connecting to the Sensor
------------------------

It is first necessary to initialize a :py:class:`~vectornav.Sensor` object, using which we will send commands to the VectorNav unit.

.. code-block:: python

    from vectornav import Sensor, Registers
    sensor = Sensor()

We can then connect to the VectorNav unit using the :func:`~vectornav.Sensor.autoConnect` method 

.. literalinclude:: ../../examples/getting_started/getting_started.py
   :language: python
   :start-at: autoConnect
   :end-at: autoConnect
   :dedent: 8

.. tip::
    If the baud rate is known then the :func:`~vectornav.Sensor.connect` method can be used, which accepts an extra parameter of the expected baud rate.
    This is a quicker call, as it does not require scanning all the baud rates.
    However, this method does not perform any verification of connectivity, so it is necessary to call :func:`~vectornav.Sensor.verifySensorConnectivity` to ensure communication.

    .. code-block:: python

        sensor.connect("COM1", Sensor.BaudRate.Baud115200)
        if not sensor.verifySensorConnectivity():
            raise Exception("Wrong baud rate or incorrect port")

    If the :func:`~vectornav.Sensor.autoConnect` method is used, no :func:`~vectornav.Sensor.autoConnect` method call is necessary, as it verifies connectivity through the auto connection process at each baud rate. It is therefore the slower of the two methods, by default requiring a maximum of 4.5 seconds.

    To maintain robustness while utilizing the speed of the :func:`~vectornav.Sensor.connect` method, the :func:`~vectornav.Sensor.autoConnect` method can be used as a fallback if :func:`~vectornav.Sensor.verifySensorConnectivity` fails.

    .. code-block:: python

        sensor.connect("COM1", Sensor.BaudRate.Baud115200)
        if not sensor.verifySensorConnectivity():
            sensor.autoConnect("COM1")
            

Changing the Baud Rate
----------------------

Once communication has been established, the baud rate can be reconfigured at any point using the :func:`~vectornav.Sensor.changeBaudRate` method.

.. code-block:: python 

    # Change baud rate on the active serial port
    sensor.changeBaudRate(Sensor.BaudRate.Baud921600)
    # Change baud rate on a specific serial port
    sensor.changeBaudRate(Sensor.BaudRate.Baud921600, Registers.BaudRate.SerialPort.Serial1)

.. note::
   The :func:`~vectornav.Sensor.changeBaudRate` method will send a command to the unit to reconfigure its baud rate on the specified serial port. If the targeted port is the currently active one, it will update the hostâ€™s baud rate to match.

.. tip::
   To ensure the baud rate change persists over a unit power cycle, a :func:`~vectornav.Sensor.writeSettings` command should be sent.
   
   .. code-block:: python

      sensor.writeSettings()

Disconnecting From the Sensor
-----------------------------

To disconnect from the unit, the :func:`~vectornav.Sensor.disconnect` method can be called.

.. literalinclude:: ../../examples/getting_started/getting_started.py
   :language: python
   :start-at: disconnect
   :end-at: disconnect
   :dedent: 4

Accessing Registers
===================
All configuration settings and many measurements are stored in one of 256 registers, which are accessible via synchronous polling and synchronous writing. 
Each of these registers are their own class with the fields for each register being public members of that class.
All of the register classes exist in :ref:`api/registers:Registers` and a submodule for the register group. 
For example, the ``SynchronizationControl`` class can be accessed as :py:class:`~vectornav.Registers.System.SyncControl`.

Both measurement registers and configuration registers can be read, whereas only configuration registers can be written. This is accomplished best using the :func:`~vectornav.Sensor.readRegister` and :func:`~vectornav.Sensor.writeRegister` methods, which are discussed in the following sections. 

The fields in each :py:class:`~vectornav.Register` object will match the fields listed in the latest ICD, which can be downloaded directly from VectorNav's website.

Reading Registers
-----------------
As discussed in :ref:`pages/key_functionality:Accessing Registers`, the :func:`~vectornav.Sensor.readRegister` method is the preferred method to read registers. To do so, you must:

   #. Create a :py:class:`~vectornav.MeasurementRegister` or :py:class:`~vectornav.ConfigurationRegister` object to be populated by the received response
   #. Call the :func:`~vectornav.Sensor.readRegister` method
   #. Access the received values in the original :py:class:`~vectornav.MeasurementRegister` or :py:class:`~vectornav.ConfigurationRegister` object

.. literalinclude:: ../../examples/getting_started/getting_started.py
   :language: python
   :start-at: modelRegister
   :end-at: print(f"Sensor Model Number: {modelRegister.model}")
   :dedent: 4


Writing Registers
-----------------
As discussed in :ref:`pages/key_functionality:Accessing Registers`, the :func:`~vectornav.Sensor.writeRegister` method is the preferred method to write to a register. 
Each :py:class:`~vectornav.ConfigurationRegister` object uses optional fields with no default values. These fields must be populated before the
:py:class:`~vectornav.ConfigurationRegister` object is used to write to the sensor. This can be done by ensuring all fields contain valid values rather than  ``None``.

To write to a sensor, you must:

   #. Create a :py:class:`~vectornav.ConfigurationRegister` object
   #. Populate the :py:class:`~vectornav.ConfigurationRegister` object with the desired values to configure the unit
   #. Call the :func:`~vectornav.Sensor.writeRegister` method

.. literalinclude:: ../../examples/getting_started/getting_started.py
   :language: python
   :start-at: Registers.System.AsyncOutputType()
   :end-at: print("ADOR Configured")
   :dedent: 4

.. tip::
   To ensure register values are not unintentionally changed, it is reccomended to first read a register, change only the desired parameter, and write the register back to the unit. This can be accomplished as follows:

   .. code-block:: python

        reg = Registers.System.SyncControl()
        try:
            sensor.readRegister(reg)
            reg.syncOutMode = Registers.System.SyncControl.SyncOutMode.ImuStart
            reg.syncOutSkipFactor = 8
            sensor.writeRegister(reg)
        except:
            print(f"Error: {latestError} encountered when reading and writing SyncControl register\n")
            return

Reading Measurements
====================

By default, all asynchronous measurements (except :attr:`~vectornav.GnssGroup.gnssSatInfo` and :attr:`~vectornav.GnssGroup.gnssRawMeas`), whether sourced from ASCII or binary outputs, are made available as a :py:class:`~vectornav.CompositeData` object on the ``MeasurementQueue`` contained within the :py:class:`~vectornav.Sensor` object once the packet is parsed.

The Composite Data Object
-------------------------

A :py:class:`~vectornav.CompositeData` object contains each measurement group (e.g. :py:attr:`~vectornav.CompositeData.attitude`), each of which is a structure containing each measurement type (e.g. :py:attr:`~vectornav.Ypr`). 
Exactly one :py:class:`~vectornav.CompositeData` object is populated for each measurement message, each of which contain a subset of the possible measurement types. 
Because a measurement message likely does not contain each enabled measurement, the measurements that do not have values in the message will hold a value of `None`.
As an example, ``accel`` is documented in the ICD in the ``Imu`` measurement group and can be accessed in a :py:class:`~vectornav.CompositeData` object as:

.. literalinclude:: ../../examples/getting_started/getting_started.py
   :language: python
   :start-at: compositeData.imu.accel
   :end-at: compositeData.imu.accel
   :dedent: 12


.. note::
   The :py:class:`~vectornav.CompositeData` class does not contain the `Common` group. As such, any measurement types populated via a binary measurement in the `Common` group will show up in the underlying group. For example, a binary message which contains :py:attr:`~vectornav.Ypr` from the `Common` group will be populated in the :py:attr:`~vectornav.CompositeData.attitude` member of a :py:class:`~vectornav.CompositeData` object.

.. caution::
   For variable length outputs *gnssSatInfo* and *gnssRawMeas*, :py:class:`~vectornav.CompositeData` stores as many entries as its internal buffer allows for those outputs (``GNSS_SAT_INFO_MAX_COUNT`` or ``GNSS_RAW_MEAS_MAX_COUNT`` respectively). These packets contain a count field (`numSats` or `numMeas` respectively) with the number of valid measurements output by the sensor for that packet.  If the count field value exceeds the storage capacity, the buffer will be filled, but the `numSats` field will remain unchanged from the value output by the sensor. To iterate through valid measurements without exceeding array bounds, users should never exceed the minimum of the count field and the internal buffer size (eg. ``min(numSats,GNSS_SAT_INFO_MAX_COUNT)``).

How to Read a Measurement
-------------------------

Reading a measurement from the unit can be done using the following steps.

#. Get a :py:class:`~vectornav.CompositeData` object using the :func:`~vectornav.Sensor.getNextMeasurement` or :func:`~vectornav.Sensor.getMostRecentMeasurement` methods.

#. Validate that the :py:class:`~vectornav.CompositeData` object is not `None`.

#. Validate the measurement you want is in the :py:class:`~vectornav.CompositeData` object. This can be done by using the :func:`~vectornav.CompositeData.matchesMessage` method. Alternatively, you could check that each individual measurement is not `None`.

#. Access the measurement value.

The following code block shows and example of reading measurements from a VectorNav unit.

.. literalinclude:: ../../examples/getting_started/getting_started.py
   :language: python
   :start-at: t0 = time.time()
   :end-at: print(f"\tAccel X: {accel[0]}\n\tAccel Y: {accel[1]}\n\tAccel Z: {accel[2]}")
   :dedent: 4

Sending Commands 
================

Each command able to be sent to the unit is available as a public method of the :py:class:`~vectornav.Sensor` class. They are all blocking calls; if non-blocking commands are necessary, refer to the :ref:`pages/advanced_functionality:Non-Blocking Commands` section.
To send a command, simply call the public method with the necessary parameters, if applicable. For example, to send a :func:`~vectornav.Sensor.knownMagneticDisturbance` command, you can call

.. literalinclude:: ../../examples/calibration/hsi_from_sensor/hsi_from_sensor.py
   :language: python
   :start-at: knownMagneticDisturbance
   :end-at: knownMagneticDisturbance
   :dedent: 4

Logging Data
============

Refer to the :ref:`plugins/logger:Logger` documentation.

Error Handling
==============

To ensure robustness in the event of an error, it is important to understand how errors are exposed to the user and the type of error handling required. Errors can be generated either synchronouslyâ€”a direct result of a user callâ€”or asynchronouslyâ€”occurring independent of a user call. The VNSDK C++ library does not throw exceptions; it instead returns error codes which are propagated to the Python code and thrown natively in Python. Because of this, all exceptions can be caught as native Python exceptions.

Synchronous Errors
------------------
Synchronous errors are classified as errors that result from a function call that can raise an exception. All user-facing functions in the Sensor class will throw unless otherwise specified. This means synchronous errors will terminate the program by default unless appropriate error handling is provided. As an example, consider a connect routine is needed that will wait for a USB device to be plugged in on a specific COM port before proceeding:

.. code-block:: python

    while True:
        try:
            print(f"Attempting to connect to {COM_PORT} ...")
            time.sleep(2) # sleep for two seconds
            sensor.connect(COM_PORT, Sensor.BaudRate.Baud115200)
            break
        except Exception as e:
            print(e)

    print("connected")

.. caution:: 
   Synchronous errors raised due to a non-blocking :func:`~vectornav.Sensor.sendCommand` call are not returned up the stack. For an example, see :ref:`pages/advanced_functionality:Non-Blocking Commands`.
   When using :func:`~vectornav.Sensor.sendCommand` while blocking, errors will be returned up the stack as expected.
   
   Regardless of the selected :class:`~vectornav.Sensor.SendCommandBlockMode`, the synchronous error from the unit will be attached to the :class:`~vectornav.GenericCommand` object and can be accessed using :func:`GenericCommand.getError() <vectornav.GenericCommand.getError>`.
    
Asynchronous Errors
-------------------
Asynchronous errors are classififed as errors that are not associated with a function call and can occur at any time. To handle such errors, the VNSDK provides a :func:`~vectornav.Sensor.throwIfAsyncError` function, that throws an exception if an error is on the asynchronous error queue. This queue should be monitored periodically to ensure proper error handling. For example, if data has not been received in an expected period of time, checking the error queue may reveal a sensor Hard Fault which would require the sensor to be reset.

.. code-block:: python

    try:
        sensor.throwIfAsyncError()
    except Exception as asyncError:
        # Handle asynchronous error

